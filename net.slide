Standard library, Net package
Internal SoftServe Golang Training
05 Jan 2017

Ivan Kutuzov
ikut@softserveinc.com
https://discuss.7insyde.com
https://golang.org.ua
@arbrix

* License and Materials

This presentation is licensed under the [[https://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike 4.0 International]] licence.

You are encouraged to remix, transform, or build upon the material, providing you give appropriate credit and distribute your contributions under the same license.

If you have suggestions or corrections to this presentation, please raise [[https://github.com/GolangUA/go-training/issues][an issue on the GitHub project]].

* Agenda

- Overview Standard Library
- Wolkthrough series
- Net package
- Net/http package

* Standard Library

One of the valuable things in Golang (about 140 packages)
- [[http://thenewstack.io/understanding-golang-packages/][Understanding Golang Packages]]
- [[https://golang.org/pkg/][pkg]]
- [[https://golang.org/src][src]]

* Wolkthrough

A series of walkthroughs to help you understand the Go standard library better.

[[https://medium.com/go-walkthrough][Go Walkthrough]]

* Go Walkthrough: io package

Go is a programming language built for working with bytes. Whether you have lists of bytes, streams of bytes, or individual bytes, Go makes it easy to process. From these simple primitives we build our abstractions and services.

[[https://medium.com/go-walkthrough/go-walkthrough-io-package-8ac5e95a9fbd][link]]

* Go Walkthrough: bytes + strings packages

Sometimes we need to work with bounded, in-memory byte slices instead. While working with a list of bytes seems simple enough, there are a lot of edge cases and common operations that make using the bytes package worthwhile.

[[https://medium.com/go-walkthrough/go-walkthrough-bytes-strings-packages-499be9f4b5bd][link]]

* Go Walkthrough: encoding package

Bytes alone don’t convey much meaning, however, once we encode data structures on top of those bytes then we can build truly useful applications.

[[https://medium.com/go-walkthrough/go-walkthrough-encoding-package-bc5e912232d][link]]

* Go Walkthrough: encoding/json package

For better or for worse, JSON is the encoding of the Internet. Its formal definition is small enough that you could write it on the back of a napkin but yet it can encode strings, numbers, booleans, nulls, maps, and arrays. 

[[https://medium.com/go-walkthrough/go-walkthrough-encoding-json-package-9681d1d37a8f][link]]

* Go Walkthrough: encoding/binary

When you need to squeeze every last bit or CPU cycle out of your protocol, one of the best tools is the encoding/binary package. It operates on the lowest level and is built for working with binary protocols.

[[https://medium.com/go-walkthrough/go-walkthrough-encoding-binary-96dc5d4abb5d][link]]

* Go Walkthrough: strconv

Formatting & parsing primitive values in Go is a common task. You probably first dipped your toes into the fmt package when you started Go, however, there’s a less commonly used package for basic formatting that’s more efficient and preserves compiler type checking.

[[https://medium.com/go-walkthrough/go-walkthrough-strconv-7a24632a9e73][link]]

* Go Walkthrough: fmt

The fmt package builds on top of our knowledge of primitive formatting options but packages it in a way that’s easier to use.

[[https://medium.com/go-walkthrough/go-walkthrough-fmt-55a14bbbfc53][link]]

* Net package

Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.

Let's go deeply.

* Net general

Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions.

* Net Dial

The Dial function connects to a server:

 conn, err := net.Dial("tcp", "golang.org:80")
 if err != nil {
 	// handle error
 }
 fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
 status, err := bufio.NewReader(conn).ReadString('\n')
 // ...

* Net Listen

The Listen function creates servers:

 ln, err := net.Listen("tcp", ":8080")
 if err != nil {
 	// handle error
 }
 for {
 	conn, err := ln.Accept()
 	if err != nil {
 		// handle error
 	}
 	go handleConnection(conn)
 }

* Net IP

An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.

 type IP []byte
 func IPv4(a, b, c, d byte) IP

* net/url

Package url parses URLs and implements query escaping. [[https://golang.org/pkg/net/url/][link]]

 u, err := url.Parse("http://bing.com/search?q=dotnet")
 if err != nil {
 	log.Fatal(err)
 }
 u.Scheme = "https"
 u.Host = "google.com"
 q := u.Query()
 q.Set("q", "golang")
 u.RawQuery = q.Encode()
 fmt.Println(u)

* net/http

Package http provides HTTP client and server implementations. [[https://golang.org/pkg/net/http/][link]]

Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:

 resp, err := http.Get("http://example.com/")
 ...
 resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)
 ...
 resp, err := http.PostForm("http://example.com/form",
 	url.Values{"key": {"Value"}, "id": {"123"}})

The client must close the response body when finished with it:

 resp, err := http.Get("http://example.com/")
 if err != nil {
 	// handle error
 }
 defer resp.Body.Close()
 body, err := ioutil.ReadAll(resp.Body)
 // ...

* net/http (continue)

For control over HTTP client headers, redirect policy, and other settings, create a Client:

 client := &http.Client{
 	CheckRedirect: redirectPolicyFunc,
 }
 
 resp, err := client.Get("http://example.com")
 // ...
 
 req, err := http.NewRequest("GET", "http://example.com", nil)
 // ...
 req.Header.Add("If-None-Match", `W/"wyzzy"`)
 resp, err := client.Do(req)
 // ...

* net/http (continue 2)

For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:

 tr := &http.Transport{
 	TLSClientConfig:    &tls.Config{RootCAs: pool},
 	DisableCompression: true,
 }
 client := &http.Client{Transport: tr}
 resp, err := client.Get("https://example.com")
 // ...

*Important* Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used.

* net/http (continue 3)

ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:

 http.Handle("/foo", fooHandler)
 
 http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
 	fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
 })
 
 log.Fatal(http.ListenAndServe(":8080", nil))

More control over the server's behavior is available by creating a custom Server:

 s := &http.Server{
 	Addr:           ":8080",
 	Handler:        myHandler,
 	ReadTimeout:    10 * time.Second,
 	WriteTimeout:   10 * time.Second,
 	MaxHeaderBytes: 1 << 20,
 }
 log.Fatal(s.ListenAndServe())

* net/http (handler)

A Handler responds to an HTTP request.

ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.

Depending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply.

Except for reading the body, handlers should not modify the provided Request.

If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and hangs up the connection.

* net/http (handler continue)

 func FileServer(root FileSystem) Handler

FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.

To use the operating system's file system implementation, use http.Dir

 func NotFoundHandler() Handler

NotFoundHandler returns a simple request handler that replies to each request with a “404 page not found” reply.

 func RedirectHandler(url string, code int) Handler

RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.

* net/http (handler continue2)

 func StripPrefix(prefix string, h Handler) Handler

StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h.

 func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler

TimeoutHandler returns a Handler that runs h with the given time limit.

* net/http type ServeMux

ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.

Patterns name fixed, rooted paths, like "/favicon.ico", or rooted subtrees, like "/images/" (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both "/images/" and "/images/thumbnails/", the latter handler will be called for paths beginning "/images/thumbnails/" and the former will receive requests for any other paths in the "/images/" subtree.

Note that since a pattern ending in a slash names a rooted subtree, the pattern "/" matches all paths not matched by other registered patterns, not just the URL with Path == "/".

Third party packages
- [[http://github.com/gorill/mux][gorilla mux]]
- [[https://github.com/julienschmidt/httprouter][HttpRouter]]

* A web server

[[https://golang.org/doc/effective_go.html#web_server][Effective Go]]

 var addr = flag.String("addr", ":1718", "http service address") // Q=17, R=18
 
 var templ = template.Must(template.New("qr").Parse(templateStr))
 
 func main() {
     flag.Parse()
     http.Handle("/", http.HandlerFunc(QR))
     err := http.ListenAndServe(*addr, nil)
     if err != nil {
         log.Fatal("ListenAndServe:", err)
     }
 }
 
 func QR(w http.ResponseWriter, req *http.Request) {
     templ.Execute(w, req.FormValue("s"))
 }
 
 const templateStr = `...


